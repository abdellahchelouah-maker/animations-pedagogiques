<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quiz Asservissement — Moderne</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --muted:#9aa4b2;
    --accent:#6ee7b7;
    --accent-2:#60a5fa;
    --danger:#fb7185;
    --glass: rgba(255,255,255,0.03);
    --radius:12px;
    --max-width:900px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background:linear-gradient(180deg,#071028 0%, #071a2a 60%);
    color:#e6eef6;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:28px;
  }

  .container{
    width:100%;
    max-width:var(--max-width);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:var(--radius);
    box-shadow: 0 10px 30px rgba(2,6,23,0.6);
    overflow:hidden;
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:0;
  }

  /* Left: quiz area */
  .quiz{
    padding:28px;
    min-height:520px;
  }

  header.quiz-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:18px;
  }
  .brand{
    display:flex;
    gap:12px;
    align-items:center;
  }
  .logo{
    width:48px;height:48px;border-radius:10px;
    background:linear-gradient(135deg,var(--accent),var(--accent-2));
    display:flex;align-items:center;justify-content:center;font-weight:700;color:#04263b;
    box-shadow:0 6px 18px rgba(96,165,250,0.12), inset 0 -6px 12px rgba(255,255,255,0.06);
  }
  .title{
    line-height:1;
  }
  .title h1{font-size:16px;margin:0;font-weight:700}
  .title p{margin:0;font-size:12px;color:var(--muted)}

  .controls{
    display:flex;
    gap:8px;
    align-items:center;
  }
  .btn{
    background:transparent;border:1px solid rgba(255,255,255,0.06);
    color:var(--accent);padding:8px 12px;border-radius:10px;font-weight:600;
    cursor:pointer;transition:all .18s;backdrop-filter: blur(4px);
  }
  .btn.secondary{color:var(--accent-2)}
  .btn:hover{transform:translateY(-2px);box-shadow:0 8px 20px rgba(2,6,23,0.5)}

  .progress{
    height:10px;background:var(--glass);border-radius:999px;overflow:hidden;margin-top:14px;
  }
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%;transition:width .4s ease}

  /* Question card */
  .card{
    margin-top:18px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    border-radius:12px;padding:20px;border:1px solid rgba(255,255,255,0.03);
  }
  .q-meta{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  .q-number{font-weight:700;color:var(--accent-2)}
  .q-type{font-size:13px;color:var(--muted);padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02)}

  .q-text{font-size:18px;margin:6px 0 14px}

  .options{display:grid;gap:10px}
  .option{
    display:flex;align-items:center;gap:12px;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);
    background:rgba(255,255,255,0.01);cursor:pointer;transition:all .14s;
  }
  .option:hover{transform:translateY(-3px)}
  .option input{accent-color:var(--accent)}
  .option .label{font-weight:600}
  .option .desc{color:var(--muted);font-size:13px}

  .actions{display:flex;justify-content:space-between;align-items:center;margin-top:16px;gap:12px}
  .nav{display:flex;gap:8px}
  .small{font-size:13px;color:var(--muted)}

  /* Right: summary panel */
  .panel{
    padding:22px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    border-left:1px solid rgba(255,255,255,0.02);
    min-width:260px;
  }
  .panel h3{margin:0 0 12px}
  .summary{
    display:grid;gap:12px;
  }
  .stat{
    display:flex;justify-content:space-between;align-items:center;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);
  }
  .stat strong{font-size:18px}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .chip{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}

  .feedback{
    margin-top:14px;padding:12px;border-radius:10px;background:rgba(0,0,0,0.25);color:var(--muted);font-size:14px;
  }
  .feedback.correct{border-left:4px solid var(--accent);color:#dffbf0}
  .feedback.wrong{border-left:4px solid var(--danger);color:#ffdbe0}

  footer.attribution{padding:12px;text-align:center;color:var(--muted);font-size:13px}

  /* Result modal */
  .result{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.8));
  }
  .result.show{display:flex}
  .result-card{background:linear-gradient(180deg,#071428,#071a2a);padding:28px;border-radius:14px;max-width:520px;width:92%;text-align:center;border:1px solid rgba(255,255,255,0.04)}
  .score{font-size:48px;font-weight:800;color:var(--accent);margin:6px 0}
  .result p{color:var(--muted);margin:8px 0 18px}

  /* Responsive */
  @media (max-width:980px){
    .container{grid-template-columns:1fr; padding-bottom:18px}
    .panel{order:2;border-left:none;border-top:1px solid rgba(255,255,255,0.02)}
  }
</style>
</head>
<body>
<div class="container" role="application" aria-labelledby="quizTitle">
  <main class="quiz" id="quizMain">
    <header class="quiz-header">
      <div class="brand">
        <div class="logo" aria-hidden="true">QA</div>
        <div class="title">
          <h1 id="quizTitle">Quiz : Systèmes asservis linéaires</h1>
          <p>17 questions — Répondez et obtenez un feedback immédiat</p>
        </div>
      </div>

      <div class="controls" aria-hidden="false">
        <button class="btn" id="restartBtn" title="Recommencer le quiz">Recommencer</button>
        <button class="btn secondary" id="showAnswersBtn" title="Afficher les bonnes réponses">Afficher réponses</button>
      </div>
    </header>

    <div class="progress" aria-hidden="true" title="Progression">
      <i id="progressBar" style="width:0%"></i>
    </div>

    <section class="card" id="questionCard" aria-live="polite">
      <!-- Contenu injecté par JS -->
    </section>

    <div class="actions">
      <div class="nav">
        <button class="btn" id="prevBtn" aria-label="Question précédente">Précédent</button>
        <button class="btn" id="nextBtn" aria-label="Question suivante">Suivant</button>
      </div>
      <div>
        <span class="small">Question <strong id="currentIndex">1</strong>/<strong id="totalCount">17</strong></span>
      </div>
    </div>

    <footer class="attribution">Interface moderne — Accessible & responsive</footer>
  </main>

  <aside class="panel" aria-labelledby="panelTitle">
    <h3 id="panelTitle">Résumé</h3>
    <div class="summary">
      <div class="stat">
        <div>
          <div class="small">Score</div>
          <strong id="score">0</strong>
        </div>
        <div>
          <div class="small">Réponses correctes</div>
          <strong id="correctCount">0</strong>
        </div>
      </div>

      <div class="stat">
        <div>
          <div class="small">Questions répondues</div>
          <strong id="answeredCount">0</strong>
        </div>
        <div>
          <div class="small">Restantes</div>
          <strong id="remainingCount">17</strong>
        </div>
      </div>

      <div>
        <div class="small">Navigation rapide</div>
        <div class="legend" id="navLegend"></div>
      </div>

      <div id="feedbackBox" class="feedback" style="display:none"></div>
    </div>
  </aside>
</div>

<!-- Result modal -->
<div class="result" id="resultModal" role="dialog" aria-modal="true" aria-labelledby="resultTitle">
  <div class="result-card">
    <h2 id="resultTitle">Résultat</h2>
    <div class="score" id="finalScore">0 / 17</div>
    <p id="resultText">Bravo — voici votre score et quelques conseils.</p>
    <div style="display:flex;gap:10px;justify-content:center;margin-top:12px">
      <button class="btn" id="closeResult">Fermer</button>
      <button class="btn secondary" id="retryResult">Recommencer</button>
    </div>
  </div>
</div>

<script>
/* Données du quiz (version corrigée et uniformisée) */
const questions = [
  {"id":1,"text":"Le but d’un système asservi linéaire est :","type":"single","options":{"a":"D’obtenir une grandeur de sortie constante","b":"D’asservir la grandeur de sortie à une consigne","c":"D’obtenir une grandeur d’entrée constante","d":"D’asservir la grandeur d’entrée à une consigne"},"correct":["b"],"feedback":{"b":"Exact : un système asservi vise à suivre une consigne.","default":"Non : l’asservissement concerne la sortie, pas l’entrée."}},
  {"id":2,"text":"Un asservissement dont la consigne est constante s’appelle :","type":"single","options":{"a":"Un asservissement régulé","b":"Une consigne régulée","c":"Une régulation asservie","d":"Une régulation"},"correct":["d"],"feedback":{"d":"Correct : une consigne constante → régulation.","default":"Non : on parle de régulation lorsque la consigne est fixe."}},
  {"id":3,"text":"On distingue deux types de boucles d’asservissement :","type":"multi","options":{"a":"La boucle refermée","b":"La boucle fermée","c":"La boucle régulée","d":"La boucle ouverte"},"correct":["b","d"],"feedback":{"ok":"Exact : boucle ouverte et boucle fermée.","ko":"Seules les boucles ouverte et fermée sont correctes.","default":"Choisissez la ou les bonnes réponses : boucle ouverte et/ou boucle fermée."}},
  {"id":4,"text":"Un système asservi fonctionne :","type":"single","options":{"a":"En boucle fermée","b":"En fonction du temps","c":"De manière programmée","d":"En boucle ouverte"},"correct":["a"],"feedback":{"a":"Exact : un système asservi implique un retour (boucle fermée).","default":"Non : l’asservissement implique généralement un retour (boucle fermée)."}},
  {"id":5,"text":"Dans un fonctionnement en boucle ouverte :","type":"single","options":{"a":"La sortie est asservie à l’entrée","b":"L’entrée est asservie à la sortie","c":"La sortie dépend de l’entrée","d":"L’entrée dépend de la sortie"},"correct":["c"],"feedback":{"c":"Correct : en boucle ouverte, la sortie dépend de l’entrée sans retour.","default":"Non : en boucle ouverte, il n’y a pas de retour de la sortie vers l’entrée."}},
  {"id":6,"text":"Dans un fonctionnement en boucle fermée :","type":"single","options":{"a":"La sortie est asservie à l’entrée","b":"L’entrée est asservie à la sortie","c":"La sortie dépend de l’entrée","d":"L’entrée dépend de la sortie"},"correct":["a"],"feedback":{"a":"Exact : la sortie suit la consigne via le retour.","default":"Non : en boucle fermée, la sortie est corrigée par le retour."}},
  {"id":7,"text":"Si ε est l’écart entre la consigne et la mesure, E l’entrée et S la sortie, le gain en boucle ouverte d’un système asservi linéaire est défini comme :","type":"single","options":{"a":"E / S","b":"S / E","c":"ε / S","d":"S / ε"},"correct":["b"],"feedback":{"b":"Exact : en boucle ouverte, le gain vaut S / E.","default":"Non : le gain en boucle ouverte est le rapport sortie / entrée."}},
  {"id":8,"text":"Un système a un gain K en boucle ouverte. Son gain en boucle fermée pour un retour unitaire vaut :","type":"single","options":{"a":"K / (1 + K)","b":"1 / (1 + K)","c":"(K + 1) / K","d":"(1 + K) / K"},"correct":["a"],"feedback":{"a":"Correct : gain BF = K / (1 + K) pour un retour unitaire.","default":"Non : la formule correcte est K / (1 + K)."}},
  {"id":9,"text":"Le gain en boucle fermée d’un système asservi linéaire à retour unitaire sera toujours :","type":"single","options":{"a":"Inférieur à son gain en boucle ouverte","b":"Égal à son gain en boucle ouverte","c":"Supérieur à son gain en boucle ouverte","d":"Indépendant de son gain en boucle ouverte"},"correct":["a"],"feedback":{"a":"Exact : le gain BF est toujours inférieur au gain BO.","default":"Non : le gain BF est généralement plus faible que le gain BO pour un retour unitaire."}},
  {"id":10,"text":"La valeur réglante se définit comme :","type":"single","options":{"a":"La différence (E - S)","b":"Le rapport S / (S + E)","c":"La différence (S - E)","d":"Le rapport K / (K + 1)"},"correct":["a"],"feedback":{"a":"Correct : la valeur réglante est E - S.","default":"Non : la valeur réglante correspond à E - S."}},
  {"id":11,"text":"L’erreur statique est :","type":"single","options":{"a":"L’écart entre la grandeur réglante et la sortie en régime permanent","b":"Le produit de la grandeur réglante par le gain en boucle ouverte","c":"L’écart entre la grandeur d’entrée et la sortie en régime permanent","d":"L’écart entre la sortie et l’entrée lorsque la consigne évolue"},"correct":["c"],"feedback":{"c":"Exact : l’erreur statique est l’écart E - S en régime permanent.","default":"Non : l’erreur statique correspond à l’écart entrée - sortie en régime permanent."}},
  {"id":12,"text":"L’erreur dite de « traînage » est :","type":"single","options":{"a":"L’écart entre la grandeur réglante et la sortie en régime permanent","b":"Le produit de la grandeur réglante par le gain en boucle ouverte","c":"L’écart entre la grandeur d’entrée et la sortie en régime permanent","d":"L’écart entre la sortie et l’entrée lorsque la consigne évolue"},"correct":["d"],"feedback":{"d":"Exact : l’erreur de traînage apparaît lorsque la consigne varie.","default":"Non : l’erreur de traînage concerne les consignes évolutives."}},
  {"id":13,"text":"Un système asservi ne comporte pas certains des éléments suivants :","type":"multi","options":{"a":"Un correcteur","b":"Un multiplicateur","c":"Un décompteur","d":"Un comparateur"},"correct":["b","c"],"feedback":{"ok":"Exact : un système asservi comporte un comparateur et un correcteur, mais pas de multiplicateur ou décompteur.","ko":"Un système asservi contient un comparateur et un correcteur, mais pas les autres éléments.","default":"Réponse incorrecte. Un S.A.L. contient typiquement un comparateur et un correcteur."}},
  {"id":14,"text":"Une seule des qualités suivantes ne caractérise pas un système asservi linéaire :","type":"single","options":{"a":"La rapidité","b":"La stabilité","c":"La précision","d":"La fidélité"},"correct":["d"],"feedback":{"d":"Correct : la fidélité n’est pas un critère d’un système asservi.","default":"Non : rapidité, stabilité et précision sont des critères classiques d’un S.A.L."}},
  {"id":15,"text":"Un correcteur à action proportionnelle engendre :","type":"single","options":{"a":"Une meilleure précision si le gain est faible","b":"Une instabilité si le gain est trop important","c":"Une meilleure rapidité avant la bande proportionnelle","d":"Des dépassements d’autant moins importants que la bande proportionnelle est grande"},"correct":["b"],"feedback":{"b":"Exact : un gain proportionnel trop élevé peut rendre le système instable.","default":"Non : l’action proportionnelle peut provoquer de l’instabilité si le gain est trop élevé."}},
  {"id":16,"text":"Un correcteur à action intégrale permet :","type":"single","options":{"a":"Une meilleure précision","b":"Une meilleure stabilité","c":"Une meilleure rapidité","d":"Une moins bonne précision"},"correct":["a"],"feedback":{"a":"Correct : l’action intégrale supprime l’erreur statique, donc améliore la précision.","default":"Non : l’action intégrale améliore la précision en annulant l’erreur statique."}},
  {"id":17,"text":"Un correcteur à action dérivée permet :","type":"single","options":{"a":"Une meilleure précision","b":"Une meilleure stabilité","c":"Une meilleure rapidité","d":"Une moins bonne précision"},"correct":["b"],"feedback":{"b":"Exact : l’action dérivée améliore la stabilité en anticipant les variations.","default":"Non : l’action dérivée améliore la stabilité du système."}}
];

/* --- État local --- */
let state = {
  index: 0,
  answers: {}, // id -> array of selected keys
  revealed: false
};

/* --- Utilitaires --- */
const el = (sel, ctx=document) => ctx.querySelector(sel);
const elAll = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));

function clamp(v,min,max){return Math.max(min,Math.min(max,v))}

/* --- Validation simple des données --- */
function validateQuestions(qs){
  const ids = new Set();
  for(const q of qs){
    if(!q.id || !q.text || !q.type || !q.options || !q.correct || !q.feedback){
      console.warn('Question mal formée', q);
      return false;
    }
    if(ids.has(q.id)){ console.warn('ID dupliqué', q.id); return false; }
    ids.add(q.id);
  }
  return true;
}

/* --- Rendu question --- */
function renderQuestion(){
  const q = questions[state.index];
  const card = el('#questionCard');
  card.innerHTML = '';

  const meta = document.createElement('div');
  meta.className = 'q-meta';
  meta.innerHTML = `<div class="q-number">Q${state.index+1} — ID ${q.id}</div><div class="q-type">${q.type === 'multi' ? 'Choix multiple' : 'Choix unique'}</div>`;
  card.appendChild(meta);

  const qtext = document.createElement('div');
  qtext.className = 'q-text';
  qtext.textContent = q.text;
  card.appendChild(qtext);

  const optionsWrap = document.createElement('div');
  optionsWrap.className = 'options';
  const selected = state.answers[q.id] || [];

  for(const [key,desc] of Object.entries(q.options)){
    const opt = document.createElement('label');
    opt.className = 'option';
    opt.tabIndex = 0;
    const input = document.createElement('input');
    input.type = q.type === 'multi' ? 'checkbox' : 'radio';
    input.name = 'opt';
    input.value = key;
    input.checked = selected.includes(key);
    input.setAttribute('aria-label', `${key} : ${desc}`);
    input.addEventListener('change', (e)=>{
      handleSelect(q.id, key, e.target.checked, q.type);
    });

    // allow clicking the whole label
    const labelWrap = document.createElement('div');
    labelWrap.style.display='flex';labelWrap.style.flexDirection='column';
    const labelTitle = document.createElement('div');
    labelTitle.className = 'label';
    labelTitle.textContent = key.toUpperCase() + '. ' + desc;
    labelWrap.appendChild(labelTitle);

    opt.appendChild(input);
    opt.appendChild(labelWrap);
    optionsWrap.appendChild(opt);
  }

  card.appendChild(optionsWrap);

  // Buttons: validate / show feedback
  const actions = document.createElement('div');
  actions.className = 'actions';
  const left = document.createElement('div');
  left.style.display='flex'; left.style.gap='8px';

  const checkBtn = document.createElement('button');
  checkBtn.className = 'btn';
  checkBtn.textContent = 'Valider';
  checkBtn.addEventListener('click', ()=> validateAnswer(q));

  const clearBtn = document.createElement('button');
  clearBtn.className = 'btn secondary';
  clearBtn.textContent = 'Effacer';
  clearBtn.addEventListener('click', ()=> { state.answers[q.id]=[]; renderQuestion(); updateSummary(); });

  left.appendChild(checkBtn);
  left.appendChild(clearBtn);

  const right = document.createElement('div');
  right.innerHTML = `<div class="small">Type: ${q.type}</div>`;

  actions.appendChild(left);
  actions.appendChild(right);

  card.appendChild(actions);

  // If answer already validated, show feedback
  const fbBox = el('#feedbackBox');
  fbBox.style.display = 'none';
  fbBox.className = 'feedback';
  if(state.answers[q.id] && state.answers[q.id].__validated){
    const validated = state.answers[q.id].__validated;
    const isCorrect = validated.correct;
    fbBox.style.display = 'block';
    fbBox.classList.toggle('correct', isCorrect);
    fbBox.classList.toggle('wrong', !isCorrect);
    fbBox.innerHTML = `<strong>${isCorrect ? 'Bonne réponse' : 'Réponse incorrecte'}</strong><div style="margin-top:8px">${validated.message}</div>`;
  }

  // Keyboard: allow Enter to validate
  card.onkeydown = (ev) => {
    if(ev.key === 'Enter') validateAnswer(q);
  };

  // update progress
  updateProgress();
}

/* --- Gestion sélection --- */
function handleSelect(qid, key, checked, type){
  if(!state.answers[qid]) state.answers[qid]=[];
  // remove internal validation marker if any
  if(state.answers[qid].__validated) delete state.answers[qid].__validated;

  if(type === 'multi'){
    if(checked){
      if(!state.answers[qid].includes(key)) state.answers[qid].push(key);
    } else {
      state.answers[qid] = state.answers[qid].filter(k=>k!==key);
    }
  } else {
    // single
    state.answers[qid] = [key];
  }
  updateSummary();
}

/* --- Validation logique --- */
function arraysEqual(a,b){
  if(!Array.isArray(a) || !Array.isArray(b)) return false;
  if(a.length !== b.length) return false;
  const sa = [...a].sort(), sb=[...b].sort();
  return sa.every((v,i)=>v===sb[i]);
}

function validateAnswer(q){
  const sel = state.answers[q.id] || [];
  // mark as answered even if empty
  if(!state.answers[q.id]) state.answers[q.id]=[];

  let isCorrect = false;
  if(q.type === 'single'){
    isCorrect = arraysEqual(sel, q.correct);
  } else {
    // multi: require exact match
    isCorrect = arraysEqual(sel, q.correct);
  }

  // prepare message
  let message = '';
  if(q.type === 'single'){
    if(isCorrect){
      const key = q.correct[0];
      message = q.feedback[key] || q.feedback.default || 'Bonne réponse.';
    } else {
      message = q.feedback.default || 'Réponse incorrecte.';
    }
  } else {
    message = isCorrect ? (q.feedback.ok || q.feedback.default) : (q.feedback.ko || q.feedback.default);
  }

  // store validation meta
  state.answers[q.id].__validated = { correct: isCorrect, message };

  // update UI
  renderQuestion();
  updateSummary();
}

/* --- Navigation --- */
function goTo(index){
  state.index = clamp(index, 0, questions.length-1);
  el('#currentIndex').textContent = state.index+1;
  renderQuestion();
}

el('#prevBtn').addEventListener('click', ()=> goTo(state.index-1));
el('#nextBtn').addEventListener('click', ()=> goTo(state.index+1));
el('#restartBtn').addEventListener('click', ()=> {
  if(!confirm('Recommencer le quiz ? Toutes les réponses seront perdues.')) return;
  state = { index:0, answers:{}, revealed:false };
  init();
});
el('#showAnswersBtn').addEventListener('click', ()=> {
  if(!confirm('Afficher toutes les bonnes réponses ?')) return;
  revealAnswers();
});

/* --- Summary / navigation legend --- */
function updateSummary(){
  const total = questions.length;
  const answered = Object.keys(state.answers).filter(k=> {
    const v = state.answers[k];
    return Array.isArray(v) && v.length>0;
  }).length;
  const validatedCount = Object.keys(state.answers).filter(k=> state.answers[k] && state.answers[k].__validated && state.answers[k].__validated.correct).length;

  el('#score').textContent = validatedCount;
  el('#correctCount').textContent = validatedCount;
  el('#answeredCount').textContent = answered;
  el('#remainingCount').textContent = total - answered;

  // nav legend
  const legend = el('#navLegend');
  legend.innerHTML = '';
  questions.forEach((q,i)=>{
    const btn = document.createElement('button');
    btn.className = 'chip';
    btn.textContent = i+1;
    btn.title = `Aller à la question ${i+1}`;
    const answeredFlag = state.answers[q.id] && state.answers[q.id].length>0;
    const validated = state.answers[q.id] && state.answers[q.id].__validated;
    if(validated){
      btn.style.background = validated.correct ? 'linear-gradient(90deg,var(--accent),var(--accent-2))' : 'rgba(251,113,133,0.12)';
      btn.style.color = validated.correct ? '#04263b' : '#ffdbe0';
    } else if(answeredFlag){
      btn.style.background = 'rgba(96,165,250,0.08)';
      btn.style.color = 'var(--accent-2)';
    } else {
      btn.style.background = 'transparent';
      btn.style.color = 'var(--muted)';
    }
    btn.addEventListener('click', ()=> { goTo(i); });
    legend.appendChild(btn);
  });

  // feedback panel: show current question feedback if validated
  const q = questions[state.index];
  const fbBox = el('#feedbackBox');
  if(state.answers[q.id] && state.answers[q.id].__validated){
    const validated = state.answers[q.id].__validated;
    fbBox.style.display = 'block';
    fbBox.classList.toggle('correct', validated.correct);
    fbBox.classList.toggle('wrong', !validated.correct);
    fbBox.innerHTML = `<strong>${validated.correct ? 'Bonne réponse' : 'Réponse incorrecte'}</strong><div style="margin-top:8px">${validated.message}</div>`;
  } else {
    fbBox.style.display = 'none';
  }

  // final score auto show if all answered
  const allAnswered = questions.every(q => state.answers[q.id] && state.answers[q.id].length>0 && state.answers[q.id].__validated);
  if(allAnswered){
    showResult();
  }
}

/* --- Progress bar --- */
function updateProgress(){
  const pct = Math.round(((state.index+1) / questions.length) * 100);
  el('#progressBar').style.width = pct + '%';
  el('#totalCount').textContent = questions.length;
  el('#currentIndex').textContent = state.index+1;
}

/* --- Reveal answers (show correct choices) --- */
function revealAnswers(){
  state.revealed = true;
  // mark each question as validated with correct message
  questions.forEach(q=>{
    const keys = q.correct;
    let message = '';
    if(q.type === 'single'){
      const key = keys[0];
      message = q.feedback[key] || q.feedback.default || 'Réponse correcte : ' + key;
    } else {
      message = q.feedback.ok || q.feedback.default || 'Réponses correctes : ' + keys.join(', ');
    }
    state.answers[q.id] = [...keys];
    state.answers[q.id].__validated = { correct: true, message };
  });
  updateSummary();
  renderQuestion();
}

/* --- Result modal --- */
function showResult(){
  const correct = Object.keys(state.answers).filter(k=> state.answers[k] && state.answers[k].__validated && state.answers[k].__validated.correct).length;
  const total = questions.length;
  el('#finalScore').textContent = `${correct} / ${total}`;
  const pct = Math.round((correct/total)*100);
  let text = '';
  if(pct === 100) text = 'Parfait — maîtrise complète.';
  else if(pct >= 80) text = 'Très bien — quelques révisions suffisent.';
  else if(pct >= 50) text = 'Moyen — révisez les points clés.';
  else text = 'À améliorer — reprenez les notions fondamentales.';
  el('#resultText').textContent = text;
  el('#resultModal').classList.add('show');
}

el('#closeResult').addEventListener('click', ()=> el('#resultModal').classList.remove('show'));
el('#retryResult').addEventListener('click', ()=> {
  el('#resultModal').classList.remove('show');
  state = { index:0, answers:{}, revealed:false };
  init();
});

/* --- Initialisation --- */
function init(){
  if(!validateQuestions(questions)){
    alert('Le jeu de questions contient des erreurs. Voir console.');
    return;
  }
  // restore minimal state from sessionStorage (optional)
  try{
    const saved = sessionStorage.getItem('quiz_state_v1');
    if(saved){
      const parsed = JSON.parse(saved);
      if(parsed && parsed.answers) state.answers = parsed.answers;
    }
  }catch(e){ /* ignore */ }

  goTo(0);
  updateSummary();
  // autos-save
  setInterval(()=> {
    try{ sessionStorage.setItem('quiz_state_v1', JSON.stringify({answers: state.answers})); }catch(e){}
  }, 2000);
}

/* --- Start --- */
init();
</script>
</body>
</html>
